#ifndef HINT_H
#define HINT_H

#include <QString>

#define COUNT   117

namespace Hint
{
    int getHint(QString text);
    const QString hints[COUNT][3] = {
        // 6502 opcodes
        {"adc", "Add Memory to Accumulator with Carry", "A + M + C -&gt; A, C"},
        {"and", "AND Memory with Accumulator", "A AND M -&gt; A"},
        {"asl", "Shift Left One Bit (Memory or Accumulator)", "C &lt;- [76543210] &lt;- 0"},
        {"bcc", "Branch on Carry Clear", "branch on C = 0"},
        {"bcs", "Branch on Carry Set", "branch on C = 1"},
        {"beq", "Branch on Result Zero", "branch on Z = 1"},
        {"bit", "Test Bits in Memory with Accumulator", "A AND M, M7 -&gt; N, M6 -&gt; V"},
        {"bmi", "Branch on Result Minus", "branch on N = 1"},
        {"bne", "Branch on Result not Zero", "branch on Z = 0"},
        {"bpl", "Branch on Result Plus", "branch on N = 0"},
        {"brk", "Force Break", "interrupt, push PC+2, push SR"},
        {"bvc", "Branch on Overflow Clear", "branch on V = 0"},
        {"bvs", "Branch on Overflow Set", "branch on V = 1"},
        {"clc", "Clear Carry Flag", "0 -&gt; C"},
        {"cld", "Clear Decimal Mode", "0 -&gt; D"},
        {"cli", "Clear Interrupt Disable Bit", "0 -&gt; I"},
        {"clv", "Clear Overflow Flag", "0 -&gt; V"},
        {"cmp", "Compare Memory with Accumulator", "A - M"},
        {"cpx", "Compare Memory and Index X", "X - M"},
        {"cpy", "Compare Memory and Index Y", "Y - M"},
        {"dec", "Decrement Memory by One", "M - 1 -&gt; M"},
        {"dex", "Decrement Index X by One", "X - 1 -&gt; X"},
        {"dey", "Decrement Index Y by One", "Y - 1 -&gt; Y"},
        {"eor", "Exclusive-OR Memory with Accumulator", "A EOR M -&gt; A"},
        {"inc", "Increment Memory by One", "M + 1 -&gt; M"},
        {"inx", "Increment Index X by One", "X + 1 -&gt; X"},
        {"iny", "Increment Index Y by One", "Y + 1 -&gt; Y"},
        {"jmp", "Jump to New Location", "(PC+1) -&gt; PCL, (PC+2) -&gt; PCH"},
        {"jsr", "Jump to New Location Saving Return Address", "push (PC+2), (PC+1) -&gt; PCL, (PC+2) -&gt; PCH"},
        {"lda", "Load Accumulator with Memory", "M -&gt; A"},
        {"ldx", "Load Index X with Memory", "M -&gt; X"},
        {"ldy", "Load Index Y with Memory", "M -&gt; Y"},
        {"lsr", "Shift One Bit Right (Memory or Accumulator)", "0 -&gt; [76543210] -&gt; C"},
        {"nop", "No Operation", "---"},
        {"ora", "OR Memory with Accumulator", "A OR M -&gt; A"},
        {"pha", "Push Accumulator on Stack", "push A"},
        {"php", "Push Processor Status on Stack", "push SR"},
        {"pla", "Pull Accumulator from Stack", "pull A"},
        {"plp", "Pull Processor Status from Stack", "pull SR"},
        {"rol", "Rotate One Bit Left (Memory or Accumulator)", "C &lt;- [76543210] &lt;- C"},
        {"ror", "Rotate One Bit Right (Memory or Accumulator)", "C -&gt; [76543210] -&gt; C"},
        {"rti", "Return from Interrupt", "pull SR, pull PC"},
        {"rts", "Return from Subroutine", "pull PC, PC+1 -&gt; PC"},
        {"sbc", "Subtract Memory from Accumulator with Borrow", "A - M - C -&gt; A"},
        {"sec", "Set Carry Flag", "1 -&gt; C"},
        {"sed", "Set Decimal Flag", "1 -&gt; D"},
        {"sei", "Set Interrupt Disable Status", "1 -&gt; I"},
        {"sta", "Store Accumulator in Memory", "A -&gt; M"},
        {"stx", "Store Index X in Memory", "X -&gt; M"},
        {"sty", "Store Index Y in Memory", "Y -&gt; M"},
        {"tax", "Transfer Accumulator to Index X", "A -&gt; X"},
        {"tay", "Transfer Accumulator to Index Y", "A -&gt; Y"},
        {"tsx", "Transfer Stack Pointer to Index X", "SP -&gt; X"},
        {"txa", "Transfer Index X to Accumulator", "X -&gt; A"},
        {"txs", "Transfer Index X to Stack Register", "X -&gt; SP"},
        {"tya", "Transfer Index Y to Accumulator", "Y -&gt; A"},
        // illegal opcodes
        {"slo", "Shift left one bit in memory, then OR accumulator with memory.", "M = M * 2, A = A OR M"},
        {"sre", "Shift right one bit in memory, then EOR accumulator with memory.", "M = M / 2, A = A EXOR M"},
        {"rla", "Rotate one bit left in memory, then AND accumulator with memory.", "M = M ROL, A = A AND M"},
        {"rra", "Rotate one bit right in memory, then add memory to accumulator (with carry).", "M = M ROR, A = A ADC M"},
        {"sax", "AND X register with accumulator and store result in memory.", "M = A AND X"},
        {"lax", "Load accumulator and X register with memory.", "A = M, X = M"},
        {"dcp", "Subtract 1 from memory (without borrow) and then CMPs the result with the A register.", "M = M - 1, A - M"},
        {"isc", "Increase memory by one, then subtract memory from accu-mulator (with borrow).", "M = M + 1, A = A - M"},
        {"anc", "AND byte with accumulator. If result is negative then carry is set.", "A = A AND M"},
        {"alr", "AND byte with accumulator, then shift right one bit in accumulator.", "A = A AND M, A = A / 2"},
        {"arr", "AND byte with accumulator, then rotate one bit right in accumulator and check bit 5 and 6:", "A = A AND M, A = A / 2"},
        {"xaa", "The contents of the X register to the A register and then ANDs the A register with an immediate value.", "A = X AND M"},
        {"shy", "AND Y register with (the high byte of the target address of the OPER) + 1. Store the result in memory.", "M = Y AND (MH + 1)"},
        {"shx", "AND X register with (the high byte of the target address of the OPER) + 1. Store the result in memory.", "M = X AND (MH + 1)"},
        {"tas", "AND X register with accumulator and store result in stack pointer, then AND stack pointer with the high byte of the target address of the OPER + 1. Store result in memory.", "S = X AND A, M = S AND (MH + 1)"},
        {"las", "AND memory with stack pointer, transfer result to accumulator, X register and stack pointer.", "A,X,S = M AND S"},
        {"ahx", "Stores the result of A AND X AND the high byte of the target address of the operand +1 in memory.", "M = A AND X AND (MH + 1)"},
        // 65c02 opcodes
        {"bbr0", "Branch on Bit Reset", "branch on bit 0 reset"},
        {"bbr1", "Branch on Bit Reset", "branch on bit 1 reset"},
        {"bbr2", "Branch on Bit Reset", "branch on bit 2 reset"},
        {"bbr3", "Branch on Bit Reset", "branch on bit 3 reset"},
        {"bbr4", "Branch on Bit Reset", "branch on bit 4 reset"},
        {"bbr5", "Branch on Bit Reset", "branch on bit 5 reset"},
        {"bbr6", "Branch on Bit Reset", "branch on bit 6 reset"},
        {"bbr7", "Branch on Bit Reset", "branch on bit 7 reset"},
        {"bbs0", "Branch on Bit Set", "branch on bit 0 set"},
        {"bbs1", "Branch on Bit Set", "branch on bit 1 set"},
        {"bbs2", "Branch on Bit Set", "branch on bit 2 set"},
        {"bbs3", "Branch on Bit Set", "branch on bit 3 set"},
        {"bbs4", "Branch on Bit Set", "branch on bit 4 set"},
        {"bbs5", "Branch on Bit Set", "branch on bit 5 set"},
        {"bbs6", "Branch on Bit Set", "branch on bit 6 set"},
        {"bbs7", "Branch on Bit Set", "branch on bit 7 set"},
        {"bra", "Branch always", "branch always"},
        {"phx", "Push X Register", "push X"},
        {"phy", "Push Y Register", "push Y"},
        {"plx", "Pull X Register", "pull X"},
        {"ply", "Pull Y Register", "pull Y"},
        {"rmb0", "Reset Memory Bit", "M = M NAND 2^0"},
        {"rmb1", "Reset Memory Bit", "M = M NAND 2^1"},
        {"rmb2", "Reset Memory Bit", "M = M NAND 2^2"},
        {"rmb3", "Reset Memory Bit", "M = M NAND 2^3"},
        {"rmb4", "Reset Memory Bit", "M = M NAND 2^4"},
        {"rmb5", "Reset Memory Bit", "M = M NAND 2^5"},
        {"rmb6", "Reset Memory Bit", "M = M NAND 2^6"},
        {"rmb7", "Reset Memory Bit", "M = M NAND 2^7"},
        {"smb0", "Set Memory Bit", "M = M OR 2^0"},
        {"smb1", "Set Memory Bit", "M = M OR 2^1"},
        {"smb2", "Set Memory Bit", "M = M OR 2^2"},
        {"smb3", "Set Memory Bit", "M = M OR 2^3"},
        {"smb4", "Set Memory Bit", "M = M OR 2^4"},
        {"smb5", "Set Memory Bit", "M = M OR 2^5"},
        {"smb6", "Set Memory Bit", "M = M OR 2^6"},
        {"smb7", "Set Memory Bit", "M = M OR 2^7"},
        {"stp", "Stop the Processor", "stop"},
        {"stz", "Stores a zero byte into Memory", "0 -&gt; M"},
        {"trb", "Test and Reset Bits", "M = M NAND A, Z = M AND A"},
        {"tsb", "Test and Set Bits", "M = M OR A, Z = M AND A"},
        {"wai", "Wait for Interrupt", "wait for interrupt"},
        // standart macro
        {"BasicUpstart", "Add BASIC line that starts your code", "10 SYS XXXX"},
        {"BasicUpstart2", "Add BASIC line that starts your code", "10 SYS XXXX"}
    };

};

#endif // HINT_H
